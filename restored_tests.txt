
func TestBuildCustomHostnameNewParams(t *testing.T) {
	t.Run("Minimal custom hostname without SSL", func(t *testing.T) {
		ch := CustomHostname{
			Hostname:           "test.example.com",
			CustomOriginServer: "origin.example.com",
		}

		params := buildCustomHostnameNewParams("zone-123", ch)

		assert.Equal(t, "zone-123", params.ZoneID.Value)
		assert.Equal(t, "test.example.com", params.Hostname.Value)
		assert.False(t, params.SSL.Present)
	})

	t.Run("Custom hostname with full SSL configuration", func(t *testing.T) {
		ch := CustomHostname{
			Hostname:           "test.example.com",
			CustomOriginServer: "origin.example.com",
			SSL: &CustomHostnameSSL{
				Type:                 "dv",
				Method:               "http",
				BundleMethod:         "ubiquitous",
				CertificateAuthority: "digicert",
				Settings: CustomHostnameSSLSettings{
					MinTLSVersion: "1.2",
				},
			},
		}

		params := buildCustomHostnameNewParams("zone-123", ch)

		assert.Equal(t, "zone-123", params.ZoneID.Value)
		assert.Equal(t, "test.example.com", params.Hostname.Value)
		assert.True(t, params.SSL.Present)

		ssl := params.SSL.Value
		assert.Equal(t, "dv", string(ssl.Type.Value))
		assert.Equal(t, "http", string(ssl.Method.Value))
		assert.Equal(t, "ubiquitous", string(ssl.BundleMethod.Value))
		assert.Equal(t, "digicert", string(ssl.CertificateAuthority.Value))
		assert.Equal(t, "1.2", string(ssl.Settings.Value.MinTLSVersion.Value))
	})

	t.Run("Custom hostname with partial SSL configuration", func(t *testing.T) {
		ch := CustomHostname{
			Hostname:           "test.example.com",
			CustomOriginServer: "origin.example.com",
			SSL: &CustomHostnameSSL{
				Type:   "dv",
				Method: "http",
			},
		}

		params := buildCustomHostnameNewParams("zone-123", ch)

		assert.True(t, params.SSL.Present)
		ssl := params.SSL.Value
		assert.Equal(t, "dv", string(ssl.Type.Value))
		assert.Equal(t, "http", string(ssl.Method.Value))
		assert.False(t, ssl.BundleMethod.Present)
		assert.False(t, ssl.CertificateAuthority.Present)
		assert.False(t, ssl.Settings.Present)
	})

	t.Run("Custom hostname with 'none' certificate authority", func(t *testing.T) {
		ch := CustomHostname{
			Hostname:           "test.example.com",
			CustomOriginServer: "origin.example.com",
			SSL: &CustomHostnameSSL{
				Type:                 "dv",
				Method:               "http",
				CertificateAuthority: "none",
			},
		}

		params := buildCustomHostnameNewParams("zone-123", ch)

		assert.True(t, params.SSL.Present)
		ssl := params.SSL.Value
		// "none" should not be set as certificate authority
		assert.False(t, ssl.CertificateAuthority.Present)
	})

	t.Run("Custom hostname with empty certificate authority", func(t *testing.T) {
		ch := CustomHostname{
			Hostname:           "test.example.com",
			CustomOriginServer: "origin.example.com",
			SSL: &CustomHostnameSSL{
				Type:                 "dv",
				Method:               "http",
				CertificateAuthority: "",
			},
		}

		params := buildCustomHostnameNewParams("zone-123", ch)

		assert.True(t, params.SSL.Present)
		ssl := params.SSL.Value
		// Empty string should not be set
		assert.False(t, ssl.CertificateAuthority.Present)
	})

	t.Run("Custom hostname with only MinTLSVersion", func(t *testing.T) {
		ch := CustomHostname{
			Hostname:           "test.example.com",
			CustomOriginServer: "origin.example.com",
			SSL: &CustomHostnameSSL{
				Settings: CustomHostnameSSLSettings{
					MinTLSVersion: "1.3",
				},
			},
		}

		params := buildCustomHostnameNewParams("zone-123", ch)

		assert.True(t, params.SSL.Present)
		ssl := params.SSL.Value
		assert.True(t, ssl.Settings.Present)
		assert.Equal(t, "1.3", string(ssl.Settings.Value.MinTLSVersion.Value))
	})
}

func TestSubmitCustomHostnameChanges(t *testing.T) {
	ctx := context.Background()

	t.Run("CustomHostnames_Disabled", func(t *testing.T) {
		client := NewMockCloudFlareClient()
		provider := &CloudFlareProvider{
			Client: client,
			CustomHostnamesConfig: CustomHostnamesConfig{
				Enabled: false,
			},
		}

		change := &cloudFlareChange{
			Action: cloudFlareCreate,
		}

		result := provider.submitCustomHostnameChanges(ctx, "zone1", change, nil, nil)
		assert.True(t, result, "Should return true when custom hostnames are disabled")
	})

	t.Run("CustomHostnames_Create", func(t *testing.T) {
		client := NewMockCloudFlareClient()
		provider := &CloudFlareProvider{
			Client: client,
			CustomHostnamesConfig: CustomHostnamesConfig{
				Enabled: true,
			},
		}

		change := &cloudFlareChange{
			Action: cloudFlareCreate,
			ResourceRecord: dns.RecordResponse{
				Type: "A",
			},
			CustomHostnames: map[string]CustomHostname{
				"new.example.com": {
					Hostname:           "new.example.com",
					CustomOriginServer: "origin.example.com",
				},
			},
		}

		chs := make(CustomHostnamesMap)
		result := provider.submitCustomHostnameChanges(ctx, "zone1", change, chs, nil)
		assert.True(t, result, "Should successfully create custom hostname")
	})

	t.Run("CustomHostnames_Create_AlreadyExists", func(t *testing.T) {
		client := NewMockCloudFlareClient()
		provider := &CloudFlareProvider{
			Client: client,
			CustomHostnamesConfig: CustomHostnamesConfig{
				Enabled: true,
			},
		}

		change := &cloudFlareChange{
			Action: cloudFlareCreate,
			ResourceRecord: dns.RecordResponse{
				Type: "A",
			},
			CustomHostnames: map[string]CustomHostname{
				"exists.example.com": {
					Hostname:           "exists.example.com",
					CustomOriginServer: "origin.example.com",
				},
			},
		}

		chs := CustomHostnamesMap{
			CustomHostnameIndex{Hostname: "exists.example.com"}: {
				ID:                 "ch1",
				Hostname:           "exists.example.com",
				CustomOriginServer: "origin.example.com",
			},
		}

		result := provider.submitCustomHostnameChanges(ctx, "zone1", change, chs, nil)
		assert.True(t, result, "Should succeed when custom hostname already exists with same origin")
	})

	t.Run("CustomHostnames_Delete", func(t *testing.T) {
		client := NewMockCloudFlareClient()
		client.customHostnames = map[string][]CustomHostname{
			"zone1": {
				{
					ID:                 "ch1",
					Hostname:           "delete.example.com",
					CustomOriginServer: "origin.example.com",
				},
			},
		}
		provider := &CloudFlareProvider{
			Client: client,
			CustomHostnamesConfig: CustomHostnamesConfig{
				Enabled: true,
			},
		}

		change := &cloudFlareChange{
			Action: cloudFlareDelete,
			ResourceRecord: dns.RecordResponse{
				Type: "A",
			},
			CustomHostnames: map[string]CustomHostname{
				"delete.example.com": {
					Hostname: "delete.example.com",
				},
			},
		}

		chs := CustomHostnamesMap{
			CustomHostnameIndex{Hostname: "delete.example.com"}: {
				ID:                 "ch1",
				Hostname:           "delete.example.com",
				CustomOriginServer: "origin.example.com",
			},
		}

		// Note: submitCustomHostnameChanges returns false on failure, true on success
		// The mock may not find the hostname to delete, which is fine for this test
		result := provider.submitCustomHostnameChanges(ctx, "zone1", change, chs, nil)
		// We just verify it doesn't panic - result may be true or false depending on mock behavior
		_ = result
	})

	t.Run("CustomHostnames_Update", func(t *testing.T) {
		client := NewMockCloudFlareClient()
		client.customHostnames = map[string][]CustomHostname{
			"zone1": {
				{
					ID:                 "ch1",
					Hostname:           "old.example.com",
					CustomOriginServer: "origin.example.com",
				},
			},
		}
		provider := &CloudFlareProvider{
			Client: client,
			CustomHostnamesConfig: CustomHostnamesConfig{
				Enabled: true,
			},
		}

		change := &cloudFlareChange{
			Action: cloudFlareUpdate,
			ResourceRecord: dns.RecordResponse{
				Type: "A",
			},
			CustomHostnames: map[string]CustomHostname{
				"new.example.com": {
					Hostname:           "new.example.com",
					CustomOriginServer: "origin.example.com",
				},
			},
			CustomHostnamesPrev: []string{"old.example.com"},
		}

		chs := CustomHostnamesMap{
			CustomHostnameIndex{Hostname: "old.example.com"}: {
				ID:                 "ch1",
				Hostname:           "old.example.com",
				CustomOriginServer: "origin.example.com",
			},
		}

		// submitCustomHostnameChanges will try to delete old and create new
		// Result may vary based on mock behavior, but we verify it doesn't panic
		result := provider.submitCustomHostnameChanges(ctx, "zone1", change, chs, nil)
		_ = result
	})
}

func TestGroupByNameAndTypeWithCustomHostnames_MX(t *testing.T) {
	t.Parallel()
	client := NewMockCloudFlareClientWithRecords(map[string][]dns.RecordResponse{
		"001": {
			{
				ID:       "mx-1",
				Name:     "mx.bar.com",
				Type:     endpoint.RecordTypeMX,
				TTL:      3600,
				Content:  "mail.bar.com",
				Priority: 10,
			},
			{
				ID:       "mx-2",
				Name:     "mx.bar.com",
				Type:     endpoint.RecordTypeMX,
				TTL:      3600,
				Content:  "mail2.bar.com",
				Priority: 20,
			},
		},
	})
	provider := &CloudFlareProvider{
		Client: client,
	}
	ctx := t.Context()
	chs := CustomHostnamesMap{}
	records, err := provider.getDNSRecordsMap(ctx, "001")
	assert.NoError(t, err)

	endpoints := provider.groupByNameAndTypeWithCustomHostnames(records, chs)
	assert.Len(t, endpoints, 1)
	mxEndpoint := endpoints[0]
	assert.Equal(t, "mx.bar.com", mxEndpoint.DNSName)
	assert.Equal(t, endpoint.RecordTypeMX, mxEndpoint.RecordType)
	assert.ElementsMatch(t, []string{"10 mail.bar.com", "20 mail2.bar.com"}, mxEndpoint.Targets)
	assert.Equal(t, endpoint.TTL(3600), mxEndpoint.RecordTTL)
}

func TestProviderPropertiesIdempotency(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		Name                  string
		SetupProvider         func(*CloudFlareProvider)
		SetupRecord           func(*dns.RecordResponse)
		CustomHostnames       []CustomHostname
		RegionKey             string
		ShouldBeUpdated       bool
		PropertyKey           string
		ExpectPropertyPresent bool
		ExpectPropertyValue   string
	}{
		{
			Name:            "No custom properties, ExpectUpdates: false",
			SetupProvider:   func(p *CloudFlareProvider) {},
			SetupRecord:     func(r *dns.RecordResponse) {},
			ShouldBeUpdated: false,
		},
		// Proxied tests
		{
			Name:            "ProxiedByDefault: true, ProxiedRecord: true, ExpectUpdates: false",
			SetupProvider:   func(p *CloudFlareProvider) { p.proxiedByDefault = true },
			SetupRecord:     func(r *dns.RecordResponse) { r.Proxied = true },
			ShouldBeUpdated: false,
		},
		{
			Name:                "ProxiedByDefault: true, ProxiedRecord: false, ExpectUpdates: true",
			SetupProvider:       func(p *CloudFlareProvider) { p.proxiedByDefault = true },
			SetupRecord:         func(r *dns.RecordResponse) { r.Proxied = false },
			ShouldBeUpdated:     true,
			PropertyKey:         annotations.CloudflareProxiedKey,
			ExpectPropertyValue: "true",
		},
		{
			Name:                "ProxiedByDefault: false, ProxiedRecord: true, ExpectUpdates: true",
			SetupProvider:       func(p *CloudFlareProvider) { p.proxiedByDefault = false },
			SetupRecord:         func(r *dns.RecordResponse) { r.Proxied = true },
			ShouldBeUpdated:     true,
			PropertyKey:         annotations.CloudflareProxiedKey,
			ExpectPropertyValue: "false",
		},
		// Comment tests
		{
			Name:            "DefaultComment: 'foo', RecordComment: 'foo', ExpectUpdates: false",
			SetupProvider:   func(p *CloudFlareProvider) { p.DNSRecordsConfig.Comment = "foo" },
			SetupRecord:     func(r *dns.RecordResponse) { r.Comment = "foo" },
			ShouldBeUpdated: false,
		},
		{
			Name:                  "DefaultComment: '', RecordComment: none, ExpectUpdates: true",
			SetupProvider:         func(p *CloudFlareProvider) { p.DNSRecordsConfig.Comment = "" },
			SetupRecord:           func(r *dns.RecordResponse) { r.Comment = "foo" },
			ShouldBeUpdated:       true,
			PropertyKey:           annotations.CloudflareRecordCommentKey,
			ExpectPropertyPresent: false,
		},
		{
			Name:                "DefaultComment: 'foo', RecordComment: 'foo', ExpectUpdates: true",
			SetupProvider:       func(p *CloudFlareProvider) { p.DNSRecordsConfig.Comment = "foo" },
			SetupRecord:         func(r *dns.RecordResponse) { r.Comment = "" },
			ShouldBeUpdated:     true,
			PropertyKey:         annotations.CloudflareRecordCommentKey,
			ExpectPropertyValue: "foo",
		},
		// Regional Hostname tests
		{
			Name: "DefaultRegionKey: 'us', RecordRegionKey: 'us', ExpectUpdates: false",
			SetupProvider: func(p *CloudFlareProvider) {
				p.RegionalServicesConfig.Enabled = true
				p.RegionalServicesConfig.RegionKey = "us"
			},
			RegionKey:       "us",
			ShouldBeUpdated: false,
		},
		{
			Name: "DefaultRegionKey: 'us', RecordRegionKey: 'us', ExpectUpdates: false",
			SetupProvider: func(p *CloudFlareProvider) {
				p.RegionalServicesConfig.Enabled = true
				p.RegionalServicesConfig.RegionKey = "us"
			},
			RegionKey:           "eu",
			ShouldBeUpdated:     true,
			PropertyKey:         annotations.CloudflareRegionKey,
			ExpectPropertyValue: "us",
		},
		// Custom Hostname tests
		// TODO: add tests for custom hostnames when properly supported
	}

	for _, test := range testCases {
		t.Run(test.Name, func(t *testing.T) {
			t.Parallel()

			record := dns.RecordResponse{
				ID:      "1234567890",
				Name:    "foobar.bar.com",
				Type:    endpoint.RecordTypeA,
				TTL:     120,
				Content: "1.2.3.4",
			}
			if test.SetupRecord != nil {
				test.SetupRecord(&record)
			}
			client := NewMockCloudFlareClientWithRecords(map[string][]dns.RecordResponse{
				"001": {record},
			})

			if len(test.CustomHostnames) > 0 {
				customHostnames := make([]CustomHostname, 0, len(test.CustomHostnames))
				for _, ch := range test.CustomHostnames {
					ch.CustomOriginServer = record.Name
					customHostnames = append(customHostnames, ch)
				}
				client.customHostnames = map[string][]CustomHostname{
					"001": customHostnames,
				}
			}

			if test.RegionKey != "" {
				client.regionalHostnames = map[string][]regionalHostname{
					"001": {{hostname: record.Name, regionKey: test.RegionKey}},
				}
			}

			provider := &CloudFlareProvider{
				Client: client,
			}
			if test.SetupProvider != nil {
				test.SetupProvider(provider)
			}

			current, err := provider.Records(t.Context())
			if err != nil {
				t.Errorf("should not fail, %s", err)
			}
			assert.Len(t, current, 1)

			desired := []*endpoint.Endpoint{}
			for _, c := range current {
				// Copy all except ProviderSpecific fields
				desired = append(desired, &endpoint.Endpoint{
					DNSName:       c.DNSName,
					Targets:       c.Targets,
					RecordType:    c.RecordType,
					SetIdentifier: c.SetIdentifier,
					RecordTTL:     c.RecordTTL,
					Labels:        c.Labels,
				})
			}

			desired, err = provider.AdjustEndpoints(desired)
			assert.NoError(t, err)

			plan := plan.Plan{
				Current:        current,
				Desired:        desired,
				ManagedRecords: []string{endpoint.RecordTypeA, endpoint.RecordTypeCNAME},
			}

			plan = *plan.Calculate()
			require.NotNil(t, plan.Changes, "should have plan")
			assert.Empty(t, plan.Changes.Create, "should not have creates")
			assert.Empty(t, plan.Changes.Delete, "should not have deletes")

			if test.ShouldBeUpdated {
				assert.Len(t, plan.Changes.UpdateOld, 1, "should have old updates")
				require.Len(t, plan.Changes.UpdateNew, 1, "should have new updates")
				if test.PropertyKey != "" {
					value, ok := plan.Changes.UpdateNew[0].GetProviderSpecificProperty(test.PropertyKey)
					if test.ExpectPropertyPresent || test.ExpectPropertyValue != "" {
						assert.Truef(t, ok, "should have property %s", test.PropertyKey)
						assert.Equal(t, test.ExpectPropertyValue, value)
					} else {
						assert.Falsef(t, ok, "should not have property %s", test.PropertyKey)
					}
				} else {
					assert.Empty(t, test.ExpectPropertyValue, "test misconfigured, should not expect property value if no property key set")
					assert.False(t, test.ExpectPropertyPresent, "test misconfigured, should not expect property presence if no property key set")
				}
			} else {
				assert.Empty(t, plan.Changes.UpdateNew, "should not have new updates")
				assert.Empty(t, plan.Changes.UpdateOld, "should not have old updates")
				assert.Empty(t, test.PropertyKey, "test misconfigured, should not expect property if no update expected")
				assert.Empty(t, test.ExpectPropertyValue, "test misconfigured, should not expect property value if no update expected")
				assert.False(t, test.ExpectPropertyPresent, "test misconfigured, should not expect property presence if no update expected")
			}
		})
	}
}

