
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>pihole: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">sigs.k8s.io/external-dns/provider/pihole/client.go (84.0%)</option>
				
				<option value="file1">sigs.k8s.io/external-dns/provider/pihole/clientV6.go (92.4%)</option>
				
				<option value="file2">sigs.k8s.io/external-dns/provider/pihole/pihole.go (76.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pihole

import (
        "context"
        "crypto/tls"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/http/cookiejar"
        "net/url"
        "strings"

        log "github.com/sirupsen/logrus"
        "golang.org/x/net/html"

        extdnshttp "sigs.k8s.io/external-dns/pkg/http"

        "sigs.k8s.io/external-dns/endpoint"
        "sigs.k8s.io/external-dns/provider"
)

// piholeAPI declares the "API" actions performed against the Pihole server.
type piholeAPI interface {
        // listRecords returns endpoints for the given record type (A or CNAME).
        listRecords(ctx context.Context, rtype string) ([]*endpoint.Endpoint, error)
        // createRecord will create a new record for the given endpoint.
        createRecord(ctx context.Context, ep *endpoint.Endpoint) error
        // deleteRecord will delete the given record.
        deleteRecord(ctx context.Context, ep *endpoint.Endpoint) error
}

// piholeClient implements the piholeAPI.
type piholeClient struct {
        cfg        PiholeConfig
        httpClient *http.Client
        token      string
}

// newPiholeClient creates a new Pihole API client.
func newPiholeClient(cfg PiholeConfig) (piholeAPI, error) <span class="cov8" title="1">{
        if cfg.Server == "" </span><span class="cov8" title="1">{
                return nil, ErrNoPiholeServer
        }</span>

        // Setup a persistent cookiejar for storing PHP session information
        // This call will never return an error
        <span class="cov8" title="1">jar, _ := cookiejar.New(&amp;cookiejar.Options{})
        // Setup an HTTP client using the cookiejar
        httpClient := &amp;http.Client{
                Jar: jar,
                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{
                                InsecureSkipVerify: cfg.TLSInsecureSkipVerify,
                        },
                },
        }

        cl := extdnshttp.NewInstrumentedClient(httpClient)

        p := &amp;piholeClient{
                cfg:        cfg,
                httpClient: cl,
        }

        if cfg.Password != "" </span><span class="cov8" title="1">{
                if err := p.retrieveNewToken(context.Background()); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return p, nil</span>
}

func (p *piholeClient) listRecords(ctx context.Context, rtype string) ([]*endpoint.Endpoint, error) <span class="cov8" title="1">{
        form := &amp;url.Values{}
        form.Add("action", "get")
        if p.token != "" </span><span class="cov8" title="1">{
                form.Add("token", p.token)
        }</span>

        <span class="cov8" title="1">url, err := p.urlForRecordType(rtype)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">log.Debugf("Listing %s records from %s", rtype, url)

        req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, strings.NewReader(form.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.Header.Add("content-type", "application/x-www-form-urlencoded")

        body, err := p.do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer body.Close()
        raw, err := io.ReadAll(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Response is a map of "data" to a list of lists where the first element in each
        // list is the dns name and the second is the target.
        // Pi-Hole does not allow for a record to have multiple targets.
        <span class="cov8" title="1">var res map[string][][]string
        if err := json.Unmarshal(raw, &amp;res); err != nil </span><span class="cov8" title="1">{
                // Unfortunately this could also just mean we needed to authenticate (still returns a 200).
                // Thankfully the body is a short and concise error.
                err = errors.New(string(raw))
                if strings.Contains(err.Error(), "expired") &amp;&amp; p.cfg.Password != "" </span><span class="cov0" title="0">{
                        // Try to fetch a new token and redo the request.
                        // Full error message at time of writing:
                        // "Not allowed (login session invalid or expired, please relogin on the Pi-hole dashboard)!"
                        log.Info("Pihole token has expired, fetching a new one")
                        if err := p.retrieveNewToken(ctx); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return p.listRecords(ctx, rtype)</span>
                }
                // Return raw body as error.
                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">out := make([]*endpoint.Endpoint, 0)
        data, ok := res["data"]
        if !ok </span><span class="cov8" title="1">{
                return out, nil
        }</span>
<span class="cov8" title="1">loop:
        for _, rec := range data </span><span class="cov8" title="1">{
                name := rec[0]
                target := rec[1]
                if !p.cfg.DomainFilter.Match(name) </span><span class="cov8" title="1">{
                        log.Debugf("Skipping %s that does not match domain filter", name)
                        continue</span>
                }
                <span class="cov8" title="1">switch rtype </span>{
                case endpoint.RecordTypeA:<span class="cov8" title="1">
                        if strings.Contains(target, ":") </span><span class="cov8" title="1">{
                                continue loop</span>
                        }
                case endpoint.RecordTypeAAAA:<span class="cov8" title="1">
                        if strings.Contains(target, ".") </span><span class="cov8" title="1">{
                                continue loop</span>
                        }
                }
                <span class="cov8" title="1">out = append(out, &amp;endpoint.Endpoint{
                        DNSName:    name,
                        Targets:    []string{target},
                        RecordType: rtype,
                })</span>
        }

        <span class="cov8" title="1">return out, nil</span>
}

func (p *piholeClient) createRecord(ctx context.Context, ep *endpoint.Endpoint) error <span class="cov8" title="1">{
        return p.apply(ctx, "add", ep)
}</span>

func (p *piholeClient) deleteRecord(ctx context.Context, ep *endpoint.Endpoint) error <span class="cov8" title="1">{
        return p.apply(ctx, "delete", ep)
}</span>

func (p *piholeClient) aRecordsScript() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/admin/scripts/pi-hole/php/customdns.php", p.cfg.Server)
}</span>

func (p *piholeClient) cnameRecordsScript() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/admin/scripts/pi-hole/php/customcname.php", p.cfg.Server)
}</span>

func (p *piholeClient) urlForRecordType(rtype string) (string, error) <span class="cov8" title="1">{
        switch rtype </span>{
        case endpoint.RecordTypeA, endpoint.RecordTypeAAAA:<span class="cov8" title="1">
                return p.aRecordsScript(), nil</span>
        case endpoint.RecordTypeCNAME:<span class="cov8" title="1">
                return p.cnameRecordsScript(), nil</span>
        default:<span class="cov8" title="1">
                return "", fmt.Errorf("unsupported record type: %s", rtype)</span>
        }
}

type actionResponse struct {
        Success bool   `json:"success"`
        Message string `json:"message"`
}

func (p *piholeClient) apply(ctx context.Context, action string, ep *endpoint.Endpoint) error <span class="cov8" title="1">{
        if !p.cfg.DomainFilter.Match(ep.DNSName) </span><span class="cov8" title="1">{
                log.Debugf("Skipping %s %s that does not match domain filter", action, ep.DNSName)
                return nil
        }</span>
        <span class="cov8" title="1">url, err := p.urlForRecordType(ep.RecordType)
        if err != nil </span><span class="cov8" title="1">{
                log.Warnf("Skipping unsupported endpoint %s %s %v", ep.DNSName, ep.RecordType, ep.Targets)
                return nil
        }</span>

        <span class="cov8" title="1">if p.cfg.DryRun </span><span class="cov8" title="1">{
                log.Infof("DRY RUN: %s %s IN %s -&gt; %s", action, ep.DNSName, ep.RecordType, ep.Targets[0])
                return nil
        }</span>

        <span class="cov8" title="1">log.Infof("%s %s IN %s -&gt; %s", action, ep.DNSName, ep.RecordType, ep.Targets[0])

        form := p.newDNSActionForm(action, ep)
        if strings.Contains(ep.DNSName, "*") </span><span class="cov8" title="1">{
                return provider.NewSoftError(errors.New("UNSUPPORTED: Pihole DNS names cannot return wildcard"))
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, strings.NewReader(form.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">req.Header.Add("content-type", "application/x-www-form-urlencoded")

        body, err := p.do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer body.Close()

        raw, err := io.ReadAll(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var res actionResponse
        if err := json.Unmarshal(raw, &amp;res); err != nil </span><span class="cov0" title="0">{
                // Unfortunately this could also be a generic server or auth error.
                err = errors.New(string(raw))
                if strings.Contains(err.Error(), "expired") &amp;&amp; p.cfg.Password != "" </span><span class="cov0" title="0">{
                        // Try to fetch a new token and redo the request.
                        log.Info("Pihole token has expired, fetching a new one")
                        if err := p.retrieveNewToken(ctx); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return p.apply(ctx, action, ep)</span>
                }
                // Return raw body as error.
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">if !res.Success </span><span class="cov0" title="0">{
                return errors.New(res.Message)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (p *piholeClient) retrieveNewToken(ctx context.Context) error <span class="cov8" title="1">{
        if p.cfg.Password == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">form := &amp;url.Values{}
        form.Add("pw", p.cfg.Password)
        url := fmt.Sprintf("%s/admin/index.php?login", p.cfg.Server)
        log.Debugf("Fetching new token from %s", url)

        req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, strings.NewReader(form.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">req.Header.Add("content-type", "application/x-www-form-urlencoded")

        body, err := p.do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer body.Close()

        // If successful the request will redirect us to an HTML page with a hidden
        // div containing the token...The token gives us access to other PHP
        // endpoints via a form value.
        p.token, err = parseTokenFromLogin(body)
        return err</span>
}

func (p *piholeClient) newDNSActionForm(action string, ep *endpoint.Endpoint) *url.Values <span class="cov8" title="1">{
        form := &amp;url.Values{}
        form.Add("action", action)
        form.Add("domain", ep.DNSName)
        switch ep.RecordType </span>{
        case endpoint.RecordTypeA, endpoint.RecordTypeAAAA:<span class="cov8" title="1">
                form.Add("ip", ep.Targets[0])</span>
        case endpoint.RecordTypeCNAME:<span class="cov8" title="1">
                form.Add("target", ep.Targets[0])</span>
        }
        <span class="cov8" title="1">if p.token != "" </span><span class="cov8" title="1">{
                form.Add("token", p.token)
        }</span>
        <span class="cov8" title="1">return form</span>
}

func (p *piholeClient) do(req *http.Request) (io.ReadCloser, error) <span class="cov8" title="1">{
        res, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if res.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                defer res.Body.Close()
                return nil, fmt.Errorf("received non-200 status code from request: %s", res.Status)
        }</span>
        <span class="cov8" title="1">return res.Body, nil</span>
}

func parseTokenFromLogin(body io.ReadCloser) (string, error) <span class="cov8" title="1">{
        doc, err := html.Parse(body)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">tokenNode := getElementById(doc, "token")
        if tokenNode == nil </span><span class="cov8" title="1">{
                return "", errors.New("could not parse token from login response")
        }</span>

        <span class="cov8" title="1">return tokenNode.FirstChild.Data, nil</span>
}

func getAttribute(n *html.Node, key string) (string, bool) <span class="cov8" title="1">{
        for _, attr := range n.Attr </span><span class="cov8" title="1">{
                if attr.Key == key </span><span class="cov8" title="1">{
                        return attr.Val, true
                }</span>
        }
        <span class="cov8" title="1">return "", false</span>
}

func hasID(n *html.Node, id string) bool <span class="cov8" title="1">{
        if n.Type == html.ElementNode </span><span class="cov8" title="1">{
                s, ok := getAttribute(n, "id")
                if ok &amp;&amp; s == id </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func traverse(n *html.Node, id string) *html.Node <span class="cov8" title="1">{
        if hasID(n, id) </span><span class="cov8" title="1">{
                return n
        }</span>

        <span class="cov8" title="1">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov8" title="1">{
                result := traverse(c, id)
                if result != nil </span><span class="cov8" title="1">{
                        return result
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func getElementById(n *html.Node, id string) *html.Node <span class="cov8" title="1">{
        return traverse(n, id)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2025 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pihole

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/netip"
        "net/url"
        "strconv"
        "strings"

        log "github.com/sirupsen/logrus"

        extdnshttp "sigs.k8s.io/external-dns/pkg/http"

        "sigs.k8s.io/external-dns/endpoint"
        "sigs.k8s.io/external-dns/provider"
)

const (
        contentTypeJSON = "application/json"
        apiAuthPath     = "/api/auth"
        apiConfigDNS    = "/api/config/dns"
)

// piholeClient implements the piholeAPI.
type piholeClientV6 struct {
        cfg        PiholeConfig
        httpClient *http.Client
        token      string
}

// newPiholeClient creates a new Pihole API V6 client.
func newPiholeClientV6(cfg PiholeConfig) (piholeAPI, error) <span class="cov8" title="1">{
        if cfg.Server == "" </span><span class="cov8" title="1">{
                return nil, ErrNoPiholeServer
        }</span>

        // Setup an HTTP client
        <span class="cov8" title="1">httpClient := &amp;http.Client{
                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{
                                InsecureSkipVerify: cfg.TLSInsecureSkipVerify,
                        },
                },
        }

        cl := extdnshttp.NewInstrumentedClient(httpClient)

        p := &amp;piholeClientV6{
                cfg:        cfg,
                httpClient: cl,
        }

        if cfg.Password != "" </span><span class="cov8" title="1">{
                if err := p.retrieveNewToken(context.Background()); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return p, nil</span>
}

func (p *piholeClientV6) getConfigValue(ctx context.Context, rtype string) ([]string, error) <span class="cov8" title="1">{
        apiUrl, err := p.urlForRecordType(rtype)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">log.Debugf("Listing %s records from %s", rtype, apiUrl)

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, apiUrl, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">jRes, err := p.do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Parse JSON response
        <span class="cov8" title="1">var apiResponse ApiRecordsResponse
        if err := json.Unmarshal(jRes, &amp;apiResponse); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to unmarshal error response: %w", err)
        }</span>

        // Pi-Hole does not allow for a record to have multiple targets.
        <span class="cov8" title="1">var results []string
        if endpoint.RecordTypeCNAME == rtype </span><span class="cov8" title="1">{
                results = apiResponse.Config.DNS.CnameRecords
        }</span> else<span class="cov8" title="1"> {
                results = apiResponse.Config.DNS.Hosts
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

/**
 * isValidIPv4 checks if the given IP address is a valid IPv4 address.
 * It returns true if the IP address is valid, false otherwise.
 * If the IP address is in IPv6 format, it will return false.
 */
func isValidIPv4(ip string) bool <span class="cov8" title="1">{
        addr, err := netip.ParseAddr(ip)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return addr.Is4()</span>
}

/**
 * isValidIPv6 checks if the given IP address is a valid IPv6 address.
 * It returns true if the IP address is valid, false otherwise.
 * If the IP address is in IPv6 with dual format y:y:y:y:y:y:x.x.x.x. , it will return true.
 */
func isValidIPv6(ip string) bool <span class="cov8" title="1">{
        addr, err := netip.ParseAddr(ip)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return addr.Is6()</span>
}

func (p *piholeClientV6) listRecords(ctx context.Context, rtype string) ([]*endpoint.Endpoint, error) <span class="cov8" title="1">{
        results, err := p.getConfigValue(ctx, rtype)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">endpoints := make(map[string]*endpoint.Endpoint)

        for _, rec := range results </span><span class="cov8" title="1">{
                recs := strings.FieldsFunc(rec, func(r rune) bool </span><span class="cov8" title="1">{
                        return r == ' ' || r == ','
                }</span>)
                <span class="cov8" title="1">if len(recs) &lt; 2 </span><span class="cov8" title="1">{
                        log.Warnf("skipping record %s: invalid format received from PiHole", rec)
                        continue</span>
                }
                <span class="cov8" title="1">var DNSName, Target string
                var Ttl = endpoint.TTL(0)
                // A/AAAA record format is target(IP) DNSName
                DNSName, Target = recs[1], recs[0]
                switch rtype </span>{
                case endpoint.RecordTypeA:<span class="cov8" title="1">
                        // PiHole return A and AAAA records. Filter to only keep the A records
                        if !isValidIPv4(Target) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                case endpoint.RecordTypeAAAA:<span class="cov8" title="1">
                        // PiHole return A and AAAA records. Filter to only keep the AAAA records
                        if !isValidIPv6(Target) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                case endpoint.RecordTypeCNAME:<span class="cov8" title="1">
                        // PiHole return only CNAME records.
                        // CNAME format is DNSName,target, ttl?
                        DNSName, Target = recs[0], recs[1]
                        if len(recs) == 3 </span><span class="cov8" title="1">{ // TTL is present
                                // Parse string to int64 first
                                if ttlInt, err := strconv.ParseInt(recs[2], 10, 64); err == nil </span><span class="cov8" title="1">{
                                        Ttl = endpoint.TTL(ttlInt)
                                }</span> else<span class="cov8" title="1"> {
                                        log.Warnf("failed to parse TTL value received from PiHole '%s': %v; using a TTL of %d", recs[2], err, Ttl)
                                }</span>
                        }
                }

                <span class="cov8" title="1">ep := endpoint.NewEndpointWithTTL(DNSName, rtype, Ttl, Target)

                if oldEp, ok := endpoints[DNSName]; ok </span><span class="cov8" title="1">{
                        ep.Targets = append(oldEp.Targets, Target)
                }</span>

                <span class="cov8" title="1">endpoints[DNSName] = ep</span>
        }

        <span class="cov8" title="1">out := make([]*endpoint.Endpoint, 0, len(endpoints))
        for _, ep := range endpoints </span><span class="cov8" title="1">{
                out = append(out, ep)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (p *piholeClientV6) createRecord(ctx context.Context, ep *endpoint.Endpoint) error <span class="cov8" title="1">{
        return p.apply(ctx, http.MethodPut, ep)
}</span>

func (p *piholeClientV6) deleteRecord(ctx context.Context, ep *endpoint.Endpoint) error <span class="cov8" title="1">{
        return p.apply(ctx, http.MethodDelete, ep)
}</span>

func (p *piholeClientV6) aRecordsScript() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s"+apiConfigDNS+"/hosts", p.cfg.Server)
}</span>

func (p *piholeClientV6) cnameRecordsScript() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s"+apiConfigDNS+"/cnameRecords", p.cfg.Server)
}</span>

func (p *piholeClientV6) urlForRecordType(rtype string) (string, error) <span class="cov8" title="1">{
        switch rtype </span>{
        case endpoint.RecordTypeA, endpoint.RecordTypeAAAA:<span class="cov8" title="1">
                return p.aRecordsScript(), nil</span>
        case endpoint.RecordTypeCNAME:<span class="cov8" title="1">
                return p.cnameRecordsScript(), nil</span>
        default:<span class="cov8" title="1">
                return "", fmt.Errorf("unsupported record type: %s", rtype)</span>
        }
}

// ApiAuthResponse Define a struct to match the JSON response /auth/app structure
type ApiAuthResponse struct {
        Session struct {
                Valid    bool   `json:"valid"`
                TOTP     bool   `json:"totp"`
                SID      string `json:"sid"`
                CSRF     string `json:"csrf"`
                Validity int    `json:"validity"`
                Message  string `json:"message"`
        } `json:"session"`
        Took float64 `json:"took"`
}

// ApiErrorResponse Define struct to match the JSON structure
type ApiErrorResponse struct {
        Error struct {
                Key     string `json:"key"`
                Message string `json:"message"`
                Hint    string `json:"hint"`
        } `json:"error"`
        Took float64 `json:"took"`
}

// ApiRecordsResponse Define struct to match JSON structure
type ApiRecordsResponse struct {
        Config struct {
                DNS struct {
                        Hosts        []string `json:"hosts"`
                        CnameRecords []string `json:"cnameRecords"`
                } `json:"dns"`
        } `json:"config"`
        Took float64 `json:"took"`
}

func (p *piholeClientV6) generateApiUrl(baseUrl, params string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/%s", baseUrl, url.PathEscape(params))
}</span>

func (p *piholeClientV6) apply(ctx context.Context, action string, ep *endpoint.Endpoint) error <span class="cov8" title="1">{
        if !p.cfg.DomainFilter.Match(ep.DNSName) </span><span class="cov8" title="1">{
                log.Debugf("Skipping : %s %s that does not match domain filter", action, ep.DNSName)
                return nil
        }</span>
        <span class="cov8" title="1">apiUrl, err := p.urlForRecordType(ep.RecordType)
        if err != nil </span><span class="cov8" title="1">{
                log.Warnf("Skipping : unsupported endpoint %s %s %v", ep.DNSName, ep.RecordType, ep.Targets)
                return nil
        }</span>

        <span class="cov8" title="1">if len(ep.Targets) == 0 </span><span class="cov8" title="1">{
                log.Infof("Skipping : missing targets  %s %s %s", action, ep.DNSName, ep.RecordType)
                return nil
        }</span>

        // Get the current record
        <span class="cov8" title="1">if strings.Contains(ep.DNSName, "*") </span><span class="cov8" title="1">{
                return provider.NewSoftError(errors.New("UNSUPPORTED: Pihole DNS names cannot return wildcard"))
        }</span>

        <span class="cov8" title="1">if ep.RecordType == endpoint.RecordTypeCNAME &amp;&amp; len(ep.Targets) &gt; 1 </span><span class="cov8" title="1">{
                return provider.NewSoftError(errors.New("UNSUPPORTED: Pihole CNAME records cannot have multiple targets"))
        }</span>

        <span class="cov8" title="1">for _, target := range ep.Targets </span><span class="cov8" title="1">{
                if p.cfg.DryRun </span><span class="cov8" title="1">{
                        log.Infof("DRY RUN: %s %s IN %s -&gt; %s", action, ep.DNSName, ep.RecordType, target)
                        continue</span>
                }

                <span class="cov8" title="1">log.Infof("%s %s IN %s -&gt; %s", action, ep.DNSName, ep.RecordType, target)

                targetApiUrl := apiUrl

                switch ep.RecordType </span>{
                case endpoint.RecordTypeA, endpoint.RecordTypeAAAA:<span class="cov8" title="1">
                        targetApiUrl = p.generateApiUrl(targetApiUrl, fmt.Sprintf("%s %s", target, ep.DNSName))</span>
                case endpoint.RecordTypeCNAME:<span class="cov8" title="1">
                        if ep.RecordTTL.IsConfigured() </span><span class="cov8" title="1">{
                                targetApiUrl = p.generateApiUrl(targetApiUrl, fmt.Sprintf("%s,%s,%d", ep.DNSName, target, ep.RecordTTL))
                        }</span> else<span class="cov8" title="1"> {
                                targetApiUrl = p.generateApiUrl(targetApiUrl, fmt.Sprintf("%s,%s", ep.DNSName, target))
                        }</span>
                }
                <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, action, targetApiUrl, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">_, err = p.do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (p *piholeClientV6) retrieveNewToken(ctx context.Context) error <span class="cov8" title="1">{
        if p.cfg.Password == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">apiUrl := fmt.Sprintf("%s"+apiAuthPath, p.cfg.Server)
        log.Debugf("Fetching new token from %s", apiUrl)

        // Define the JSON payload
        jsonData := []byte(`{"password":"` + p.cfg.Password + `"}`)

        req, err := http.NewRequestWithContext(ctx, http.MethodPost, apiUrl, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">jRes, err := p.do(req)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Parse JSON response
        <span class="cov8" title="1">var apiResponse ApiAuthResponse
        if err := json.Unmarshal(jRes, &amp;apiResponse); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Auth Query : failed to unmarshal error response: %v", err)
        }</span> else<span class="cov8" title="1"> {
                // Set the token
                if apiResponse.Session.SID != "" </span><span class="cov8" title="1">{
                        p.token = apiResponse.Session.SID
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

func (p *piholeClientV6) checkTokenValidity(ctx context.Context) (bool, error) <span class="cov8" title="1">{
        if p.token == "" </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">apiUrl := fmt.Sprintf("%s"+apiAuthPath, p.cfg.Server)

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, apiUrl, nil)
        if err != nil </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">req.Header.Add("content-type", contentTypeJSON)
        if p.token != "" </span><span class="cov8" title="1">{
                req.Header.Add("X-FTL-SID", p.token)
        }</span>
        <span class="cov8" title="1">res, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">jRes, err := io.ReadAll(res.Body)
        defer res.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Parse JSON response
        <span class="cov8" title="1">var apiResponse ApiAuthResponse
        if err := json.Unmarshal(jRes, &amp;apiResponse); err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("failed to unmarshal error response: %w", err)
        }</span>
        <span class="cov8" title="1">return apiResponse.Session.Valid, nil</span>
}

func (p *piholeClientV6) do(req *http.Request) ([]byte, error) <span class="cov8" title="1">{
        req.Header.Add("content-type", contentTypeJSON)
        if p.token != "" </span><span class="cov8" title="1">{
                req.Header.Add("X-FTL-SID", p.token)
        }</span>
        <span class="cov8" title="1">res, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">jRes, err := io.ReadAll(res.Body)
        defer res.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if res.StatusCode != http.StatusOK &amp;&amp;
                res.StatusCode != http.StatusCreated &amp;&amp;
                res.StatusCode != http.StatusNoContent </span><span class="cov8" title="1">{
                // Parse JSON response
                var apiError ApiErrorResponse
                if err := json.Unmarshal(jRes, &amp;apiError); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to unmarshal error response: %w", err)
                }</span>
                // Ignore if the entry already exists when adding a record
                <span class="cov8" title="1">if strings.Contains(apiError.Error.Message, "Item already present") </span><span class="cov0" title="0">{
                        return jRes, nil
                }</span>
                // Ignore if the entry does not exist when deleting a record
                <span class="cov8" title="1">if res.StatusCode == http.StatusNotFound &amp;&amp; req.Method == http.MethodDelete </span><span class="cov0" title="0">{
                        return jRes, nil
                }</span>
                <span class="cov8" title="1">if log.IsLevelEnabled(log.DebugLevel) </span><span class="cov0" title="0">{
                        log.Debugf("Error on request %s", req.URL)
                        if req.Body != nil </span><span class="cov0" title="0">{
                                log.Debugf("Body of the request %s", req.Body)
                        }</span>
                }

                <span class="cov8" title="1">if res.StatusCode == http.StatusUnauthorized &amp;&amp; p.token != "" </span><span class="cov8" title="1">{
                        tryCount := 1
                        maxRetries := 3
                        // Try to fetch a new token and redo the request.
                        for tryCount &lt;= maxRetries </span><span class="cov8" title="1">{
                                valid, err := p.checkTokenValidity(req.Context())
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">if !valid </span><span class="cov8" title="1">{
                                        log.Debugf("Pihole token has expired, fetching a new one. Try (%d/%d)", tryCount, maxRetries)
                                        if err := p.retrieveNewToken(req.Context()); err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov8" title="1">tryCount++
                                        continue</span>
                                }
                                <span class="cov8" title="1">break</span>
                        }
                        <span class="cov8" title="1">if tryCount &gt; maxRetries </span><span class="cov8" title="1">{
                                return nil, errors.New("max tries reached for token renewal")
                        }</span>
                        <span class="cov8" title="1">return p.do(req)</span>
                }
                <span class="cov8" title="1">return nil, fmt.Errorf("received %d status code from request: [%s] %s (%s) - %fs", res.StatusCode, apiError.Error.Key, apiError.Error.Message, apiError.Error.Hint, apiError.Took)</span>
        }
        <span class="cov8" title="1">return jRes, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pihole

import (
        "context"
        "errors"
        "slices"

        "github.com/google/go-cmp/cmp"

        "sigs.k8s.io/external-dns/endpoint"
        "sigs.k8s.io/external-dns/plan"
        "sigs.k8s.io/external-dns/provider"
)

// ErrNoPiholeServer is returned when there is no Pihole server configured
// in the environment.
var ErrNoPiholeServer = errors.New("no pihole server found in the environment or flags")

// PiholeProvider is an implementation of Provider for Pi-hole Local DNS.
type PiholeProvider struct {
        provider.BaseProvider
        api        piholeAPI
        apiVersion string
}

// PiholeConfig is used for configuring a PiholeProvider.
type PiholeConfig struct {
        // The root URL of the Pi-hole server.
        Server string
        // An optional password if the server is protected.
        Password string
        // Disable verification of TLS certificates.
        TLSInsecureSkipVerify bool
        // A filter to apply when looking up and applying records.
        DomainFilter *endpoint.DomainFilter
        // Do nothing and log what would have changed to stdout.
        DryRun bool
        // PiHole API version =&lt;5 or &gt;=6, default is 5
        APIVersion string
}

// Helper struct for de-duping DNS entry updates.
type piholeEntryKey struct {
        Target     string
        RecordType string
}

// NewPiholeProvider initializes a new Pi-hole Local DNS based Provider.
func NewPiholeProvider(cfg PiholeConfig) (*PiholeProvider, error) <span class="cov8" title="1">{
        var api piholeAPI
        var err error
        switch cfg.APIVersion </span>{
        case "6":<span class="cov8" title="1">
                api, err = newPiholeClientV6(cfg)</span>
        default:<span class="cov8" title="1">
                api, err = newPiholeClient(cfg)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;PiholeProvider{api: api, apiVersion: cfg.APIVersion}, nil</span>
}

// Records implements Provider, populating a slice of endpoints from
// Pi-Hole local DNS.
func (p *PiholeProvider) Records(ctx context.Context) ([]*endpoint.Endpoint, error) <span class="cov8" title="1">{
        aRecords, err := p.api.listRecords(ctx, endpoint.RecordTypeA)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">aaaaRecords, err := p.api.listRecords(ctx, endpoint.RecordTypeAAAA)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cnameRecords, err := p.api.listRecords(ctx, endpoint.RecordTypeCNAME)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">aRecords = append(aRecords, aaaaRecords...)
        return append(aRecords, cnameRecords...), nil</span>
}

// ApplyChanges implements Provider, syncing desired state with the Pi-hole server Local DNS.
func (p *PiholeProvider) ApplyChanges(ctx context.Context, changes *plan.Changes) error <span class="cov8" title="1">{
        // Handle pure deletes first.
        for _, ep := range changes.Delete </span><span class="cov8" title="1">{
                if err := p.api.deleteRecord(ctx, ep); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Handle updated state - there are no endpoints for updating in place.
        <span class="cov8" title="1">updateNew := make(map[piholeEntryKey]*endpoint.Endpoint)
        for _, ep := range changes.UpdateNew </span><span class="cov8" title="1">{
                key := piholeEntryKey{ep.DNSName, ep.RecordType}

                // If the API version is 6, we need to handle multiple targets for the same DNS name.
                if p.apiVersion == "6" </span><span class="cov8" title="1">{
                        if existing, ok := updateNew[key]; ok </span><span class="cov0" title="0">{
                                existing.Targets = append(existing.Targets, ep.Targets...)

                                // Deduplicate targets
                                slices.Sort(existing.Targets)
                                existing.Targets = slices.Compact(existing.Targets)

                                ep = existing
                        }</span>
                }
                <span class="cov8" title="1">updateNew[key] = ep</span>
        }

        <span class="cov8" title="1">for _, ep := range changes.UpdateOld </span><span class="cov8" title="1">{
                // Check if this existing entry has an exact match for an updated entry and skip it if so.
                key := piholeEntryKey{ep.DNSName, ep.RecordType}
                if newRecord := updateNew[key]; newRecord != nil </span><span class="cov8" title="1">{
                        // If the API version is 6, we need to handle multiple targets for the same DNS name.
                        if p.apiVersion == "6" </span><span class="cov8" title="1">{
                                if cmp.Diff(ep.Targets, newRecord.Targets) == "" </span><span class="cov0" title="0">{
                                        delete(updateNew, key)
                                        continue</span>
                                }
                        } else<span class="cov8" title="1"> {
                                // For API version &lt;= 5, we only check the first target.
                                if newRecord.Targets[0] == ep.Targets[0] </span><span class="cov8" title="1">{
                                        delete(updateNew, key)
                                        continue</span>
                                }
                        }

                        <span class="cov8" title="1">if err := p.api.deleteRecord(ctx, ep); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // Handle pure creates before applying new updated state.
        <span class="cov8" title="1">for _, ep := range changes.Create </span><span class="cov8" title="1">{
                if err := p.api.createRecord(ctx, ep); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">for _, ep := range updateNew </span><span class="cov8" title="1">{
                if err := p.api.createRecord(ctx, ep); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
